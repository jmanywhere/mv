// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-kysely"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL_PS")
  relationMode = "prisma"
}

model Raise {
  id            String           @id @default(dbgenerated("(uuid())")) // uuid() need to be in parentheses to work
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  contract      String
  tokenRaised   String // Token Name of Raise
  raised        BigInt
  goal          BigInt
  showcase      Boolean
  ownerId       String
  description   String
  logo_icon     String
  banner        String
  name          String
  chainId       Int
  flexibleStart Boolean
  startTime     DateTime
  referrerId    String? // wallet Address
  userId        String?
  acceptTerms   String // wallet needs to sign message to accept terms
  pledges       Int // Number of people that pledged
  type          RaiseType
  chain         Chain            @relation(fields: [chainId], references: [id])
  owner         User             @relation("owner", fields: [ownerId], references: [id])
  referrer      User?            @relation("referrer", fields: [referrerId], references: [id])
  User          User?            @relation(fields: [userId], references: [id])
  upsells       Upsell[]
  features      Feature[]
  writeups      Writeup[]
  socials       SocialsOnFunds[]
  TagsOnRaise   TagsOnRaise[]
  reports       Report[]

  @@index([chainId], name: "raise_chain")
  @@index([ownerId], name: "raise_owner")
  @@index([referrerId], name: "raise_referrer")
  @@index([userId], name: "raise_user")
}

model Feature {
  id       String @id @default(dbgenerated("(uuid())"))
  duration BigInt
  raise    Raise  @relation(fields: [raiseId], references: [id])
  raiseId  String

  @@index([raiseId], name: "feature_raise")
}

model Writeup {
  id       String @id @default(dbgenerated("(uuid())"))
  raiseId  String // uuid
  text     String
  authorId String // wallet Address
  raise    Raise  @relation(fields: [raiseId], references: [id])
  user     User   @relation(fields: [authorId], references: [id])

  @@index([raiseId], name: "writeup_raise")
  @@index([authorId], name: "writeup_author")
}

model User {
  id          String    @id @unique // wallet, not autogenerated
  alias       String?   @unique
  writer      Boolean
  dev         Boolean
  auditor     Boolean
  referrer    Boolean
  other       Boolean
  contact     String?
  contact2    String?
  otherDetail String?
  Writeup     Writeup[]
  raises      Raise[]   @relation("owner")
  referred    Raise[]   @relation("referrer")
  Raise       Raise[]
  Upsells     Upsell[]
}

// Necessary Model to fulfill the Many-Many relations
model SocialsOnFunds {
  raise    Raise   @relation(fields: [raiseId], references: [id])
  social   Social  @relation(fields: [socialId], references: [id])
  verified Boolean
  raiseId  String
  socialId Int
  removed  Boolean @default(false)

  @@id([raiseId, socialId])
  @@index([socialId], name: "socialsOnFunds_social")
  @@index([raiseId], name: "socialsOnFunds_raise")
}

// TODO we should get a form of validation for socials. In the meantime this is going to have to be a manual process
model Social {
  id    Int              @id @unique @default(autoincrement())
  type  String
  url   String           @unique
  funds SocialsOnFunds[]
}

model Chain {
  id           Int            @id @unique // This is ChainId
  name         String
  Raise        Raise[]
  PaymentToken PaymentToken[]
}

model PaymentToken {
  id       String  @id @unique // This is token address (let's use a uuid)
  address  String // This can be 0x0000 for default ETH values
  name     String
  symbol   String
  decimals Int
  chainId  Int
  logo     String? // optional since we'll be pulling from other sources... COINGECKO MAYBE?
  chain    Chain   @relation(fields: [chainId], references: [id])

  //  We can support multiple payment tokens per chain, but since (theoretically) each token will have it's own address, we can just use the address as the id
  @@index([chainId], name: "paymentToken_chain")
}

model Tag {
  id          Int           @id @unique @default(autoincrement())
  name        String        @unique
  TagsOnRaise TagsOnRaise[]
}

model TagsOnRaise {
  raise   Raise  @relation(fields: [raiseId], references: [id])
  tag     Tag    @relation(fields: [tagId], references: [id])
  raiseId String
  tagId   Int

  @@id([raiseId, tagId])
  @@index([tagId], name: "tagsOnRaise_tag")
  @@index([raiseId], name: "tagsOnRaise_raise")
}

model Report {
  id       String @id @default(dbgenerated("(uuid())"))
  raise    Raise  @relation(fields: [raiseId], references: [id])
  raiseId  String // uuid
  text     String
  reporter String // wallet Address

  @@index([raiseId], name: "report_raise")
}

model Upsell {
  id         String     @id @default(dbgenerated("(uuid())"))
  raise      Raise      @relation(fields: [raiseId], references: [id])
  raiseId    String // uuid
  name       String
  executorId String // wallet Address
  executor   User       @relation(fields: [executorId], references: [id])
  amount     BigInt
  type       UpsellType
  routeName  String // for whitelabels
  otherType  String?
  token      String // Token Name

  @@index([raiseId], name: "upsell_raise")
  @@index([executorId], name: "upsell_executor")
}

enum SocialTypes {
  TWITTER
  FB
  DISCORD
  TELEGRAM
  MEDIUM
  REDDIT
}

enum RaiseType {
  FUNDRAISE
  CROWDSALE
  CHARITY
}

enum UpsellType {
  WHITELABEL
  DEV
  AUDIT
  MARKETING
  OTHER
}
